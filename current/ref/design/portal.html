
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>What is Connectal? &#8212; connectal 20.05.1 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/tracking.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Interface Declarations" href="interface_definitions.html" />
    <link rel="prev" title="Portal Interface Structure" href="portalstructure.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../bsv-pkgindex.html" title="Bsv Package Index"
             >bsvpkgs</a> |</li>
        <li class="right" >
          <a href="interface_definitions.html" title="Interface Declarations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="portalstructure.html" title="Portal Interface Structure"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">connectal 20.05.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="design.html" accesskey="U">Connectal Design</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="what-is-connectal">
<h1>What is Connectal?<a class="headerlink" href="#what-is-connectal" title="Permalink to this headline">¶</a></h1>
<p>Connectal provides a hardware-software interface for applications split
between user mode code and custom hardware in an FPGA or ASIC.</p>
<p>Connectal can automaticaly build the software and hardware glue for a
message based interface and also provides for configuring and using
shared memory between applications and hardware. Communications
between hardware and software are provided by a bidirectional flow of
events and regions of memory shared between hardware and software.
Events from software to hardware are called requests and events from
hardware to software are called indications, but in fact they are
symmetric.</p>
<div class="section" id="lexicon">
<h2>Lexicon<a class="headerlink" href="#lexicon" title="Permalink to this headline">¶</a></h2>
<p>connectal:: The name of the project, whose goal is to ease the task of
building applications composed of hardware and software components.
Programmers use bsv as an IDL to specify the interface between the
hardware and software components.  A combination of generated code and
libraries coordinate the data-flow between the program modules.
Because the HW and SW stacks are customized for each application, the
overheads associated with communicating across the HW/SW boundary are
low.</p>
<p>HW/SW interface :: portal</p>
<p>bsv:: Bluespec System Verilog.  bsv is a language for describing hardware that is might higher level than verilog. See {bsvdocumentation}[BSV Documentation] and {bluespecdotcom}[Bluespec, Inc].</p>
<p>bluespec:: Shorthand for Bluespec System Verilog (bsv)</p>
<p>indexterm:portal
portal:: a logical request/indication pair is referred to as a portal.  current tools require their specification in the IDL to be syntactically identifiable (i.e. fooRequest/fooIndication).  An application can make use of multiple portals, which may be specified independently.</p>
<p>request interface:: These methods are implemented by the application hardware to be invoked by application software.   A bsv interface consisting of ‘Action’ methods.  Because of the ‘Action’ type, data flow across this interface is unidirectional (SW -&gt; HW).</p>
<p>indication interface:: The dual of a request interface, indication interfaces are ‘Action’ methods implemented by application software to be invoked by application hardware.   As with request interfaces, the data flow across this interface is unidirectional, but in the opposite direction.</p>
<p>pcieportal/zynqportal:: these two loadable kernel modules implement the minimal set of driver functionality.  Specifically, they expose portal HW registers to SW through mmap, and set up interrupts to notify SW that an indication method has been invoked by HW.</p>
<p>portalalloc:: This loadable kernel module exposes a subset of dma-buf functionality to user-space software (though a set of ioctl commands) to allocate and manage memory regions which can be shared between SW and HW processes.   Maintaining coherence of the allocated buffers between processes is not automatic: ioctl commands for flush/invalidate are provided to be invoked explicitly by the users if necessary.</p>
<p>connectalgen:: The name of the interface compiler which takes as input the bsv interface specification along with a description of a target platform and generates logic in both HW and SW to support this interface across the communication fabric.</p>
</div>
<div class="section" id="example-setups">
<h2>Example setups:<a class="headerlink" href="#example-setups" title="Permalink to this headline">¶</a></h2>
<p>A zedboard ( <a class="reference external" href="http://www.zedboard.org/">http://www.zedboard.org/</a> ),
with Android running on the embedded ARM processors (the Processing
System 7), an application running as a user process, and custom
hardware configured into the Programmable Logic FPGA.</p>
<p>An x86 server, with Linux running on the host processor, an
application running partly as a user process on the host and partly as
hardware configured into an FPGA connected by PCI express (such as the
Xilinx VC707
(<a class="reference external" href="http://www.xilinx.com/products/boards-and-kits/EK-V7-VC707-G.htm">http://www.xilinx.com/products/boards-and-kits/EK-V7-VC707-G.htm</a>).</p>
</div>
<div class="section" id="background">
<h2>Background<a class="headerlink" href="#background" title="Permalink to this headline">¶</a></h2>
<p>When running part or all of an application in an FPGA, it is usually
necessary to communicate between code running in user mode on the host
and the hardware.  Typically this has been accomplished by custom
device drivers in the OS, or by shared memory mapped between the
software and the hardware, or both.  Shared memory has been
particularly troublesome under Linux or Android, because devices
frequently require contiguous memory, and the mechanisms for
guaranteeing successful memory allocation often require reserving the
maximum amount of memory at boot time.</p>
<p>Portal tries to provide convenient solutions to these problems in a portable way.</p>
<p>It is desirable to have</p>
<ul class="simple">
<li><p>low latency for small messages</p></li>
<li><p>high bandwidth for large messages</p></li>
<li><p>notification of arriving messages</p></li>
<li><p>asynchronous replies to messages</p></li>
<li><p>support for hardware simulation by a separate user mode process</p></li>
<li><p>support for shared memory (DMA) between hardware and software</p></li>
</ul>
</div>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Portal is implemented as a loadable kernel module device driver for Linux/Android and a set of tools to automatically construct the hardware and software glue necessary for communications.</p>
<p>Short messages are handled by programmed I/O.  The message interface
from software to hardware (so called “requests”) is defined as a bsv
interface containing a number of Action methods, each with a name and
typed arguments.  The interface generator creates all the software and
hardware glue so that software invocations of the interface stubs flow
through to, and are turned into bsv invocations of the matching
hardware.  The machinery does not have flow control. Software is
responsible for not overrunning the hardware.  There is a debug
mechanism which will return the request type of a failed method, but
it does not tell which invocation failed.  Hardware to software
interfaces (so called “indications”) are likewise defined by bsv
interfaces containing Action methods. Hardware invocations of these
methods flow through to and cause software calls to corresponding
user-supplied functions.  In the current implementation there is flow
control, in that the hardware will stall until there is room for a
hardware to software message.  There is also a mechanism for software
to report a failure, and there is machinery for these failures to be
returned to the hardware.</p>
<blockquote>
<div><dl class="simple">
<dt>{</dt><dd><p>// edge label
SW -&gt; HW [label = “request”];
SW &lt;- HW [label = “indication”];</p>
</dd>
</dl>
</div></blockquote>
<p>Portals do not have to be structured as request/response. Hardware can
send messages to software without a prior request from software.</p>
<blockquote>
<div><dl class="simple">
<dt>{</dt><dd><p>// edge label
SW &lt;- HW [label = “indication”];</p>
</dd>
</dl>
</div></blockquote>
<p>Incoming messages can cause host interrupts, which wake up the device
driver, which can wake up the user mode application by using the
select(2) or poll(2) interfaces.</p>
<p>Most of the time, communications between hardware and software will
proceed without requiring use of the OS.  User code will read and
write directly to memory mapped I/O space. Library code will poll for
incoming messages, and [true? eventually time out and call poll(2).
Only when poll(2) or select(2) are called will the device driver
enable hardware interrupts.  Thus interrupts are only used to wake up
software after a quiet period.</p>
<p>The designer specifies a set of hardware functions that can be called
from software, and a set of actions that the hardware can take which
result in messages to software. Portal tools take this specification
and build software glue modules to translate software function calls
into I/O writes to hardware registers, and to report hardware events
to software.</p>
<p>For larger memory and OS bypass (OS bypass means letting the user mode
application talk directly to the hardware without using the OS except
for setup), portal implements shared memory.  Portal memory objects
are allocated by the user mode program, and appear as Linux file
descriptors. The user can mmap(2) the file to obtain user mode access
to the shared memory region. Portal does not assure that the memory is
physically contiguous, but does pin it to prevent the OS from reusing
the memory.  An FPGA DMA controller module is provided that gives the
illusion of contiguous memory to application hardware, while under the
covers using a translation table of scattered addresses.</p>
<p>The physical addresses are provided to the user code in order to
initialize the dma controller, and address “handles” are provided for
the application hardware to use.</p>
<p>The DMA controller provides Bluespec objects that support streaming access with automatic page crossings, or random access.</p>
</div>
<div class="section" id="an-example">
<h2>An Example<a class="headerlink" href="#an-example" title="Permalink to this headline">¶</a></h2>
<p>An application developer will typically write the hardware part of the
application in Bluespec and the software part of the application in C
or C++.  In a short example, there will be a bsv source file for the
hardware and a cpp source file for the application.</p>
<p>The application developer is free to specify whatever hardware-software interface makes sense.</p>
<p>Refer to <a class="reference external" href="https://github.com/cambridgehackers/connectal">https://github.com/cambridgehackers/connectal</a></p>
<p>In the examples directory, see [simple](../examples/simple/).  The
file [Simple.bsv](../examples/simple/Simple.bsv) defines the hardware,
and testsimple.cpp supplies the software part. In this case, the
software part is a test framework for the hardware.</p>
<p>Simple.bsv declares a few <cite>struct</cite> and <cite>enum</cite> types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span><span class="p">{</span>
   <span class="n">Bit</span><span class="c1">#(32) a;</span>
   <span class="n">Bit</span><span class="c1">#(32) b;</span>
   <span class="p">}</span> <span class="n">S1</span> <span class="n">deriving</span> <span class="p">(</span><span class="n">Bits</span><span class="p">);</span>

<span class="n">typedef</span> <span class="n">struct</span><span class="p">{</span>
   <span class="n">Bit</span><span class="c1">#(32) a;</span>
   <span class="n">Bit</span><span class="c1">#(16) b;</span>
   <span class="n">Bit</span><span class="c1">#(7) c;</span>
   <span class="p">}</span> <span class="n">S2</span> <span class="n">deriving</span> <span class="p">(</span><span class="n">Bits</span><span class="p">);</span>

<span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span>
   <span class="n">E1Choice1</span><span class="p">,</span>
   <span class="n">E1Choice2</span><span class="p">,</span>
   <span class="n">E1Choice3</span>
   <span class="p">}</span> <span class="n">E1</span> <span class="n">deriving</span> <span class="p">(</span><span class="n">Bits</span><span class="p">,</span><span class="n">Eq</span><span class="p">);</span>

<span class="n">typedef</span> <span class="n">struct</span><span class="p">{</span>
   <span class="n">Bit</span><span class="c1">#(32) a;</span>
   <span class="n">E1</span> <span class="n">e1</span><span class="p">;</span>
   <span class="p">}</span> <span class="n">S3</span> <span class="n">deriving</span> <span class="p">(</span><span class="n">Bits</span><span class="p">);</span>
</pre></div>
</div>
<p>Simple.bsv defines the actions (called Requests) that software can use
to cause the hardware to act, and defines the notifications (called
Indications) that the hardware can use to signal the software.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interface</span> <span class="n">SimpleIndication</span><span class="p">;</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">heard1</span><span class="p">(</span><span class="n">Bit</span><span class="c1">#(32) v);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">heard2</span><span class="p">(</span><span class="n">Bit</span><span class="c1">#(16) a, Bit#(16) b);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">heard3</span><span class="p">(</span><span class="n">S1</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">heard4</span><span class="p">(</span><span class="n">S2</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">heard5</span><span class="p">(</span><span class="n">Bit</span><span class="c1">#(32) a, Bit#(64) b, Bit#(32) c);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">heard6</span><span class="p">(</span><span class="n">Bit</span><span class="c1">#(32) a, Bit#(40) b, Bit#(32) c);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">heard7</span><span class="p">(</span><span class="n">Bit</span><span class="c1">#(32) a, E1 e1);</span>
<span class="n">endinterface</span>

<span class="n">interface</span> <span class="n">SimpleRequest</span><span class="p">;</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">say1</span><span class="p">(</span><span class="n">Bit</span><span class="c1">#(32) v);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">say2</span><span class="p">(</span><span class="n">Bit</span><span class="c1">#(16) a, Bit#(16) b);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">say3</span><span class="p">(</span><span class="n">S1</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">say4</span><span class="p">(</span><span class="n">S2</span> <span class="n">v</span><span class="p">);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">say5</span><span class="p">(</span><span class="n">Bit</span><span class="c1">#(32)a, Bit#(64) b, Bit#(32) c);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">say6</span><span class="p">(</span><span class="n">Bit</span><span class="c1">#(32)a, Bit#(40) b, Bit#(32) c);</span>
    <span class="n">method</span> <span class="n">Action</span> <span class="n">say7</span><span class="p">(</span><span class="n">S3</span> <span class="n">v</span><span class="p">);</span>
<span class="n">endinterface</span>
</pre></div>
</div>
<p>Software can start the hardware working via say, say2, … Hardware
signals back to software with heard and heard2 and so fort.  In the
case of this example, say and say2 merely echo their arguments back to
software.</p>
<p>The definitions in the bsv file are used by the connectal infrastructure ( a python program)  to automatically create corresponding c++ interfaces.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">../../</span><span class="n">connectalgen</span> <span class="o">-</span><span class="n">Bbluesim</span> <span class="o">-</span><span class="n">p</span> <span class="n">bluesim</span> <span class="o">-</span><span class="n">x</span> <span class="n">mkBsimTop</span> \
     <span class="o">-</span><span class="n">s2h</span> <span class="n">SimpleRequest</span> \
     <span class="o">-</span><span class="n">h2s</span> <span class="n">SimpleIndication</span> \
     <span class="o">-</span><span class="n">s</span> <span class="n">testsimple</span><span class="o">.</span><span class="n">cpp</span> \
     <span class="o">-</span><span class="n">t</span> <span class="o">../../</span><span class="n">bsv</span><span class="o">/</span><span class="n">BsimTop</span><span class="o">.</span><span class="n">bsv</span>  <span class="n">Simple</span><span class="o">.</span><span class="n">bsv</span> <span class="n">Top</span><span class="o">.</span><span class="n">bsv</span>
</pre></div>
</div>
<p>The tools have to be told which interface records should be used for
Software to Hardware messages and which should be used for Hardware to
Software messages. These interfaces are given on the command line for
genxpprojfrombsv</p>
<p>connectalgen constructs all the hardware and software modules
needed to wire up portals. This is sort of like an RPC compiler for
the hardware-software interface. However, unlike an RPC each method is
asynchronous.</p>
<p>The user must also create a toplevel bsv module Top.bsv, which
instantiates the user portals, the standard hardware environment, and
any additional hardware modules.</p>
<p>Rather than constructing the <em>makefilegen</em> command line from
scratch, the examples in connectal use include
<em>Makefile.connectal</em> and define some <em>make</em>
variables.</p>
<p>Here is the Makefile for the <cite>simple</cite> example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CONNECTALDIR?=../..
INTERFACES = SimpleRequest SimpleIndication
BSVFILES = Simple.bsv Top.bsv
CPPFILES=testsimple.cpp

include $(CONNECTALDIR)/Makefile.connectal
</pre></div>
</div>
<p>Designs outside the connectal directory using <cite>connectal</cite> may also include <cite>Makefile.connectal</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>CONNECTALDIR?=/scratch/connectal
INTERFACES = ...
BSVFILES = ...
CPPFILES = ...
include $(CONNECTALDIR)/Makefile.connectal
</pre></div>
</div>
</div>
<div class="section" id="simple-top-bsv">
<h2>simple/Top.bsv<a class="headerlink" href="#simple-top-bsv" title="Permalink to this headline">¶</a></h2>
<p>Each CONNECTAL design implements [Top.bsv](../examples/simple/Top.bsv) with some standard components.</p>
<p>It defines the <cite>IfcNames</cite> enum, for use in identifying the portals between software and hardware:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">enum</span> <span class="p">{</span><span class="n">SimpleIndication</span><span class="p">,</span> <span class="n">SimpleRequest</span><span class="p">}</span> <span class="n">IfcNames</span> <span class="n">deriving</span> <span class="p">(</span><span class="n">Eq</span><span class="p">,</span><span class="n">Bits</span><span class="p">);</span>
</pre></div>
</div>
<p>It defines <cite>mkConnectalTop</cite>, which instantiates the wrappers, proxies, and the design itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">mkConnectalTop</span><span class="p">(</span><span class="n">StdConnectalTop</span><span class="c1">#(addrWidth));</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">bsv:module:StdConnectalTop is parameterized by <cite>addrWidth</cite> because Zynq and x86 have different width addressing. <cite>StdConnectalTop</cite> is a typedef:</dt>
<dd class="field-odd"><p>typedef ConnectalTop#(addrWidth,64,Empty)     StdConnectalTop#(numeric type addrWidth);</p>
</dd>
</dl>
<p>The “64” specifies the data width and <cite>Empty</cite> specifies the empty
interface is exposed as pins from the design. In designs using HDMI,
for example, <cite>Empty</cite> is replaced by <cite>HDMI</cite>.  On some platforms, the
design may be able to use different data widths, such as 128 bits on
x86/PCIe.</p>
<p>Next, <cite>mkConnectalTop</cite> instantiates user portals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">instantiate</span> <span class="n">user</span> <span class="n">portals</span>
   <span class="n">SimpleIndicationProxy</span> <span class="n">simpleIndicationProxy</span> <span class="o">&lt;-</span> <span class="n">mkSimpleIndicationProxy</span><span class="p">(</span><span class="n">SimpleIndication</span><span class="p">);</span>
</pre></div>
</div>
<p>Instantiate the design:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SimpleRequest</span> <span class="n">simpleRequest</span> <span class="o">&lt;-</span> <span class="n">mkSimpleRequest</span><span class="p">(</span><span class="n">simpleIndicationProxy</span><span class="o">.</span><span class="n">ifc</span><span class="p">);</span>
</pre></div>
</div>
<p>Instantiate the wrapper for the design:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SimpleRequestWrapper</span> <span class="n">simpleRequestWrapper</span> <span class="o">&lt;-</span> <span class="n">mkSimpleRequestWrapper</span><span class="p">(</span><span class="n">SimpleRequest</span><span class="p">,</span><span class="n">simpleRequest</span><span class="p">);</span>
</pre></div>
</div>
<p>Collect the portals into a vector:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span><span class="c1">#(2,StdPortal) portals;</span>
<span class="n">portals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpleRequestWrapper</span><span class="o">.</span><span class="n">portalIfc</span><span class="p">;</span>
<span class="n">portals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">simpleIndicationProxy</span><span class="o">.</span><span class="n">portalIfc</span><span class="p">;</span>
</pre></div>
</div>
<p>Create an interrupt multiplexer from the vector of portals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">interrupt_mux</span> <span class="o">&lt;-</span> <span class="n">mkInterruptMux</span><span class="p">(</span><span class="n">portals</span><span class="p">);</span>
</pre></div>
</div>
<p>Create the system directory, which is used by software to locate each portal via the <cite>IfcNames</cite> enum:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">instantiate</span> <span class="n">system</span> <span class="n">directory</span>
<span class="n">StdDirectory</span> <span class="nb">dir</span> <span class="o">&lt;-</span> <span class="n">mkStdDirectory</span><span class="p">(</span><span class="n">portals</span><span class="p">);</span>
<span class="n">let</span> <span class="n">ctrl_mux</span> <span class="o">&lt;-</span> <span class="n">mkAxiSlaveMux</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span><span class="n">portals</span><span class="p">);</span>
</pre></div>
</div>
<p>The following generic interfaces are used by the platform specific top BSV module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>   <span class="n">interface</span> <span class="n">interrupt</span> <span class="o">=</span> <span class="n">interrupt_mux</span><span class="p">;</span>
   <span class="n">interface</span> <span class="n">ctrl</span> <span class="o">=</span> <span class="n">ctrl_mux</span><span class="p">;</span>
   <span class="n">interface</span> <span class="n">m_axi</span> <span class="o">=</span> <span class="n">null_axi_master</span><span class="p">;</span>
   <span class="n">interface</span> <span class="n">leds</span> <span class="o">=</span> <span class="n">echoRequestInternal</span><span class="o">.</span><span class="n">leds</span><span class="p">;</span>

<span class="n">endmodule</span> <span class="p">:</span> <span class="n">mkConnectalTop</span>
</pre></div>
</div>
</div>
<div class="section" id="simple-testsimple-cpp">
<h2>simple/testsimple.cpp<a class="headerlink" href="#simple-testsimple-cpp" title="Permalink to this headline">¶</a></h2>
<p>CONNECTAL generates header files declaring wrappers for
hardware-to-software interfaces and proxies for software-to-hardware
interfaces. These will be in the “jni/” subdirectory of the project directory.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;SimpleIndication.h&quot;</span>
<span class="c1">#include &quot;SimpleRequest.h&quot;</span>
</pre></div>
</div>
<p>It also declares software equivalents for structs and enums declared in the processed BSV files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#include &quot;GeneratedTypes.h&quot;</span>
</pre></div>
</div>
<p>CONNECTAL generates abstract virtual base classes for each Indication interface.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimpleIndicationWrapper</span> <span class="p">:</span> <span class="n">public</span> <span class="n">Portal</span> <span class="p">{</span>

<span class="n">public</span><span class="p">:</span>
    <span class="o">...</span>
    <span class="n">SimpleIndicationWrapper</span><span class="p">(</span><span class="nb">int</span> <span class="nb">id</span><span class="p">,</span> <span class="n">PortalPoller</span> <span class="o">*</span><span class="n">poller</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">virtual</span> <span class="n">void</span> <span class="n">heard1</span> <span class="p">(</span> <span class="n">const</span> <span class="n">uint32_t</span> <span class="n">v</span> <span class="p">)</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Implement subclasses of the wrapper in order to define the callbacks:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SimpleIndication</span> <span class="p">:</span> <span class="n">public</span> <span class="n">SimpleIndicationWrapper</span>
<span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="o">...</span>
    <span class="n">virtual</span> <span class="n">void</span> <span class="n">heard1</span><span class="p">(</span><span class="n">uint32_t</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s2">&quot;heard1(</span><span class="si">%d</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
      <span class="k">assert</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">v1a</span><span class="p">);</span>
      <span class="n">incr_cnt</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="o">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To connect these classes to the hardware, instantiate them using the
<cite>IfcNames</cite> enum identifiers. CONNECTAL prepends the name of the type
because C++ does not support overloading of enum tags.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SimpleIndication</span> <span class="o">*</span><span class="n">indication</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SimpleIndication</span><span class="p">(</span><span class="n">IfcNames_SimpleIndication</span><span class="p">);</span>
<span class="n">SimpleRequestProxy</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">new</span> <span class="n">SimpleRequestProxy</span><span class="p">(</span><span class="n">IfcNames_SimpleRequest</span><span class="p">);</span>
</pre></div>
</div>
<p>Create a thread for handling notifications from hardware:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span>  <span class="n">portalExec</span><span class="p">,</span> <span class="n">NULL</span><span class="p">)){</span>
  <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now the software invokes hardware methods via the proxy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="o">-&gt;</span><span class="n">say1</span><span class="p">(</span><span class="n">v1a</span><span class="p">);</span>

<span class="n">device</span><span class="o">-&gt;</span><span class="n">say2</span><span class="p">(</span><span class="n">v2a</span><span class="p">,</span><span class="n">v2b</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="simple-example-design-structure">
<h2>Simple Example Design Structure<a class="headerlink" href="#simple-example-design-structure" title="Permalink to this headline">¶</a></h2>
<p>The <cite>simple</cite> example consists of the following files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Simple</span><span class="o">.</span><span class="n">bsv</span>
<span class="n">Makefile</span>
<span class="n">Top</span><span class="o">.</span><span class="n">bsv</span>
<span class="n">testsimple</span><span class="o">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p>After running <cite>make BOARD=zedboard verilog</cite> in the <cite>simple</cite> directory,
the <cite>zedboard</cite> project directory is created, populated by the generated files.</p>
<p>A top level <cite>Makefile</cite> is created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">Makefile</span>
</pre></div>
</div>
<p>makefilegen generates wrappers for software-to-hardware interfaces and proxies for hardware-to-software interfaces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">sources</span><span class="o">/</span><span class="n">mkzynqtop</span><span class="o">/</span><span class="n">SimpleIndicationProxy</span><span class="o">.</span><span class="n">bsv</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">sources</span><span class="o">/</span><span class="n">mkzynqtop</span><span class="o">/</span><span class="n">SimpleRequestWrapper</span><span class="o">.</span><span class="n">bsv</span>
</pre></div>
</div>
<p>Connectal supports Android on Zynq platforms, so connectalgen generates <cite>jni/Android.mk</cite> for <cite>ndk-build</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">jni</span><span class="o">/</span><span class="n">Android</span><span class="o">.</span><span class="n">mk</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">jni</span><span class="o">/</span><span class="n">Application</span><span class="o">.</span><span class="n">mk</span>
</pre></div>
</div>
<p>Connectal generates <cite>jni/Makefile</cite> to compile the software for PCIe platforms (vc707 and kc705):</p>
<blockquote>
<div><p>zedboard/jni/Makefile</p>
</div></blockquote>
<p>CONNECTAL generates software proxies for software-to-hardware interfaces and software wrappers for hardware-to-software interfaces:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">jni</span><span class="o">/</span><span class="n">SimpleIndication</span><span class="o">.</span><span class="n">h</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">jni</span><span class="o">/</span><span class="n">SimpleIndication</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">jni</span><span class="o">/</span><span class="n">SimpleRequest</span><span class="o">.</span><span class="n">cpp</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">jni</span><span class="o">/</span><span class="n">SimpleRequest</span><span class="o">.</span><span class="n">h</span>
</pre></div>
</div>
<p>CONNECTAL also generates <cite>GeneratedTypes.h</cite> for struct and enum types in the processed BSV source files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">jni</span><span class="o">/</span><span class="n">GeneratedTypes</span><span class="o">.</span><span class="n">h</span>
</pre></div>
</div>
<p>CONNECTAL copies in standard and specified constraints files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">constraints</span><span class="o">/</span><span class="n">design_1_processing_system7_1_0</span><span class="o">.</span><span class="n">xdc</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">constraints</span><span class="o">/</span><span class="n">zedboard</span><span class="o">.</span><span class="n">xdc</span>
</pre></div>
</div>
<p>CONNECTAL generates several TCL files to run <cite>vivado</cite>.</p>
<p>The <cite>board.tcl</cite> file specifies <cite>partname</cite>, <cite>boardname</cite>, and <cite>connectaldir</cite> for the other TCL scripts.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">board</span><span class="o">.</span><span class="n">tcl</span>
</pre></div>
</div>
<p>To generate an FPGA bit file, run <cite>make bits</cite>. This runs vivado with the <cite>mkzynqtop-impl.tcl</cite> script.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">mkzynqtop</span><span class="o">-</span><span class="n">impl</span><span class="o">.</span><span class="n">tcl</span>
</pre></div>
</div>
<div class="section" id="make-verilog">
<h3>make verilog<a class="headerlink" href="#make-verilog" title="Permalink to this headline">¶</a></h3>
<p>Compiling to verilog results in the following verilog files:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">verilog</span><span class="o">/</span><span class="n">top</span><span class="o">/</span><span class="n">mkSimpleIndicationProxySynth</span><span class="o">.</span><span class="n">v</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">verilog</span><span class="o">/</span><span class="n">top</span><span class="o">/</span><span class="n">mkZynqTop</span><span class="o">.</span><span class="n">v</span>
</pre></div>
</div>
<p>Verilog library files referenced in the design are copied for use in synthesis.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">verilog</span><span class="o">/</span><span class="n">top</span><span class="o">/</span><span class="n">FIFO1</span><span class="o">.</span><span class="n">v</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="make-bits">
<h3>make bits<a class="headerlink" href="#make-bits" title="Permalink to this headline">¶</a></h3>
<p>Running <cite>make bits</cite> in the zedboard directory results in timing reports:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">mkzynqtop_post_place_timing_summary</span><span class="o">.</span><span class="n">rpt</span>
<span class="n">zedboard</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">mkzynqtop_post_route_timing_summary</span><span class="o">.</span><span class="n">rpt</span>
<span class="n">zedboard</span><span class="o">/</span><span class="nb">bin</span><span class="o">/</span><span class="n">mkzynqtop_post_route_timing</span><span class="o">.</span><span class="n">rpt</span>
</pre></div>
</div>
<p>and some design checkpoints:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">mkzynqtop_post_synth</span><span class="o">.</span><span class="n">dcp</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">mkzynqtop_post_place</span><span class="o">.</span><span class="n">dcp</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">mkzynqtop_post_route</span><span class="o">.</span><span class="n">dcp</span>
</pre></div>
</div>
<p>and the FPGA configuration file in .bit and .bin formats:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">zedboard</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">mkZynqTop</span><span class="o">.</span><span class="n">bit</span>
<span class="n">zedboard</span><span class="o">/</span><span class="n">hw</span><span class="o">/</span><span class="n">mkZynqTop</span><span class="o">.</span><span class="n">bin</span>
</pre></div>
</div>
</div>
<div class="section" id="make-android-exe">
<h3>make android_exe<a class="headerlink" href="#make-android-exe" title="Permalink to this headline">¶</a></h3>
<p>CONNECTAL supports Android 4.0 on Zynq platforms. It generates
<cite>jni/Android.mk</cite> which is used by <cite>ndk-build</cite> to create a native
Android executable.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">android_exe</span>
</pre></div>
</div>
<p>This produces the ARM elf executable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">libs</span><span class="o">/</span><span class="n">armeabi</span><span class="o">/</span><span class="n">android_exe</span>
</pre></div>
</div>
</div>
<div class="section" id="make-run">
<h3>make run<a class="headerlink" href="#make-run" title="Permalink to this headline">¶</a></h3>
<p>For Zynq platforms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">run</span>
</pre></div>
</div>
<p>will copy the Android executable and FPGA configuration file to the
target device, program the FPGA, and run the executable. See
[run.android](../scripts/run.android) for details.</p>
<p>It uses <cite>checkip</cite> to determine the IP address of the
device via a USB console connection to the device (it is built/installed
on the host machine from the git repo cambridgehackers/consolable). If the target is
not connected to the build machine via USB, specify the IP address of
the target manually:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">make</span> <span class="n">RUNPARAM</span><span class="o">=</span><span class="n">ipaddr</span> <span class="n">run</span>
</pre></div>
</div>
<p>For PCIe platforms, <cite>make run</cite> programs the FPGA via USB and runs the software locally.</p>
<p>For bluesim, <cite>make run</cite> invokes bluesim on the design and runs the software locally.</p>
</div>
</div>
<div class="section" id="shared-memory">
<h2>Shared Memory<a class="headerlink" href="#shared-memory" title="Permalink to this headline">¶</a></h2>
<div class="section" id="shared-memory-hardware">
<h3>Shared Memory Hardware<a class="headerlink" href="#shared-memory-hardware" title="Permalink to this headline">¶</a></h3>
<p>In order to use shared memory, the hardware design instantiates a DMA module in Top.bsv:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">AxiDmaServer</span><span class="c1">#(addrWidth,64) dma &lt;- mkAxiDmaServer(dmaIndicationProxy.ifc, readClients, writeClients);</span>
</pre></div>
</div>
<p>The AxiDmaServer multiplexes read and write requests from the
clients, translates DMA addresses to physical addresses, initiates bus
transactions to memory, and delivers responses to the clients.</p>
<p>DMA requests are specified with respect to “portal” memory allocated
by software and identified by a <cite>pointer</cite>.</p>
<p>Requests and responses are tagged in order to enable pipelining:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
   <span class="n">SGLId</span> <span class="n">pointer</span><span class="p">;</span>
   <span class="n">Bit</span><span class="c1">#(MemOffsetSize) offset;</span>
   <span class="n">Bit</span><span class="c1">#(8) burstLen;</span>
   <span class="n">Bit</span><span class="c1">#(6)  tag;</span>
   <span class="p">}</span> <span class="n">MemRequest</span> <span class="n">deriving</span> <span class="p">(</span><span class="n">Bits</span><span class="p">);</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="p">{</span>
   <span class="n">Bit</span><span class="c1">#(dsz) data;</span>
   <span class="n">Bit</span><span class="c1">#(6) tag;</span>
   <span class="p">}</span> <span class="n">MemData</span><span class="c1">#(numeric type dsz) deriving (Bits);</span>
</pre></div>
</div>
<p>Read clients implement the <cite>MemReadClient</cite> interface. On response to
the read, <cite>burstLen</cite> <cite>MemData</cite> items will be put to the <cite>readData</cite>
interface. The design must be ready to consume the data when it is
delivered from the memory bus or the system may hang:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interface</span> <span class="n">MemReadClient</span><span class="c1">#(numeric type dsz);</span>
   <span class="n">interface</span> <span class="n">GetF</span><span class="c1">#(MemRequest)    readReq;</span>
   <span class="n">interface</span> <span class="n">PutF</span><span class="c1">#(MemData#(dsz)) readData;</span>
<span class="n">endinterface</span>
</pre></div>
</div>
<p>Write clients implement <cite>MemWriteClient</cite>. To complete the transaction,
<cite>burstLen</cite> data items will be consumed from the <cite>writeData</cite>
interace. Upon completion of the request, the specified tag will be
put to the <cite>writeDone</cite> interface. The data must be available when the
write request is issued to the memory bus or the system may hang:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interface</span> <span class="n">MemWriteClient</span><span class="c1">#(numeric type dsz);</span>
   <span class="n">interface</span> <span class="n">GetF</span><span class="c1">#(MemRequest)    writeReq;</span>
   <span class="n">interface</span> <span class="n">GetF</span><span class="c1">#(MemData#(dsz)) writeData;</span>
   <span class="n">interface</span> <span class="n">PutF</span><span class="c1">#(Bit#(6))       writeDone;</span>
<span class="n">endinterface</span>
</pre></div>
</div>
<p>A design may implement <cite>MemReadClient</cite> and <cite>MemWriteClient</cite> interfaces directly, or it may instantiate DmaReadBuffer or DmaWriteBuffer.</p>
<p>The <cite>AxiDmaServer</cite> is configured with physical address translations
for each region of memory identified by a <cite>pointer</cite>. A design using
DMA must export the <cite>DmaConfig</cite> and <cite>DmaIndication</cite> interfaces of the
DMA server.</p>
<p>Here are the DMA components of [memread_nobuff/Top.bsv](../examples/memread_nobuff/Top.bsv):</p>
<p>Instantiate the design and its interface wrappers and proxies:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MemreadIndicationProxy</span> <span class="n">memreadIndicationProxy</span> <span class="o">&lt;-</span> <span class="n">mkMemreadIndicationProxy</span><span class="p">(</span><span class="n">MemreadIndication</span><span class="p">);</span>
<span class="n">Memread</span> <span class="n">memread</span> <span class="o">&lt;-</span> <span class="n">mkMemread</span><span class="p">(</span><span class="n">memreadIndicationProxy</span><span class="o">.</span><span class="n">ifc</span><span class="p">);</span>
<span class="n">MemreadRequestWrapper</span> <span class="n">memreadRequestWrapper</span> <span class="o">&lt;-</span> <span class="n">mkMemreadRequestWrapper</span><span class="p">(</span><span class="n">MemreadRequest</span><span class="p">,</span><span class="n">memread</span><span class="o">.</span><span class="n">request</span><span class="p">);</span>
</pre></div>
</div>
<p>Collect the read and write clients:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span><span class="c1">#(1, MemReadClient#(64)) readClients = cons(memread.dmaClient, nil);</span>
<span class="n">Vector</span><span class="c1">#(0, MemReadClient#(64)) writeClients = nil;</span>
</pre></div>
</div>
<p>Instantiate the DMA server and its wrapper and proxy:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DmaIndicationProxy</span> <span class="n">dmaIndicationProxy</span> <span class="o">&lt;-</span> <span class="n">mkDmaIndicationProxy</span><span class="p">(</span><span class="n">DmaIndication</span><span class="p">);</span>
<span class="n">AxiDmaServer</span><span class="c1">#(addrWidth,64) dma &lt;- mkAxiDmaServer(dmaIndicationProxy.ifc, readClients, writeClients);</span>
<span class="n">DmaConfigWrapper</span> <span class="n">dmaConfigWrapper</span> <span class="o">&lt;-</span> <span class="n">mkDmaConfigWrapper</span><span class="p">(</span><span class="n">DmaConfig</span><span class="p">,</span><span class="n">dma</span><span class="o">.</span><span class="n">request</span><span class="p">);</span>
</pre></div>
</div>
<p>Include <cite>DmaConfig</cite> and <cite>DmaIndication</cite> in the portals of the design:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Vector</span><span class="c1">#(4,StdPortal) portals;</span>
<span class="n">portals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">memreadRequestWrapper</span><span class="o">.</span><span class="n">portalIfc</span><span class="p">;</span>
<span class="n">portals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">memreadIndicationProxy</span><span class="o">.</span><span class="n">portalIfc</span><span class="p">;</span>
<span class="n">portals</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmaConfigWrapper</span><span class="o">.</span><span class="n">portalIfc</span><span class="p">;</span>
<span class="n">portals</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">dmaIndicationProxy</span><span class="o">.</span><span class="n">portalIfc</span><span class="p">;</span>
</pre></div>
</div>
<p>The code generation tools will then produce the software glue necessary for the shared memory support libraries to initialize the DMA “library module” included in the hardware.</p>
</div>
<div class="section" id="shared-memory-software">
<h3>Shared Memory Software<a class="headerlink" href="#shared-memory-software" title="Permalink to this headline">¶</a></h3>
<p>The software side instantiates the DmaConfig proxy and the DmaIndication wrapper:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dma</span> <span class="o">=</span> <span class="n">new</span> <span class="n">DmaConfigProxy</span><span class="p">(</span><span class="n">IfcNames_DmaConfig</span><span class="p">);</span>
<span class="n">dmaIndication</span> <span class="o">=</span> <span class="n">new</span> <span class="n">DmaIndication</span><span class="p">(</span><span class="n">dma</span><span class="p">,</span> <span class="n">IfcNames_DmaIndication</span><span class="p">);</span>
</pre></div>
</div>
<p>Call <cite>dma-&gt;alloc()</cite> to allocate DMA memory. Each chunk of portal
memory is identified by a file descriptor. Portal memory may be shared
with other processes. Portal memory is reference counted according to
the number of file descriptors associated with it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PortalAlloc</span> <span class="o">*</span><span class="n">srcAlloc</span><span class="p">;</span>
<span class="n">dma</span><span class="o">-&gt;</span><span class="n">alloc</span><span class="p">(</span><span class="n">alloc_sz</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srcAlloc</span><span class="p">);</span>
</pre></div>
</div>
<p>Memory map it to make it accessible to software:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">srcBuffer</span> <span class="o">=</span> <span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="o">*</span><span class="p">)</span><span class="n">mmap</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alloc_sz</span><span class="p">,</span> <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="o">|</span><span class="n">PROT_EXEC</span><span class="p">,</span> <span class="n">MAP_SHARED</span><span class="p">,</span> <span class="n">srcAlloc</span><span class="o">-&gt;</span><span class="n">header</span><span class="o">.</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>Connectal is currently using non-snooped interfaces, so the cache must be flushed and invalidated before hardware accesses portal memory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dma</span><span class="o">-&gt;</span><span class="n">dCacheFlushInval</span><span class="p">(</span><span class="n">srcAlloc</span><span class="p">,</span> <span class="n">srcBuffer</span><span class="p">);</span>
</pre></div>
</div>
<p>Call <cite>dma-&gt;reference()</cite> to get a pointer that may be passed to hardware:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ref_srcAlloc</span> <span class="o">=</span> <span class="n">dma</span><span class="o">-&gt;</span><span class="n">reference</span><span class="p">(</span><span class="n">srcAlloc</span><span class="p">);</span>
</pre></div>
</div>
<p>This also transfers the DMA-to-physical address translation information to the hardware via the <cite>DmaConfig</cite> interface:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">device</span><span class="o">-&gt;</span><span class="n">startRead</span><span class="p">(</span><span class="n">ref_srcAlloc</span><span class="p">,</span> <span class="n">numWords</span><span class="p">,</span> <span class="n">burstLen</span><span class="p">,</span> <span class="n">iterCnt</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="notes">
<h2>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h2>
<div class="section" id="stewart-notes">
<h3>stewart notes<a class="headerlink" href="#stewart-notes" title="Permalink to this headline">¶</a></h3>
<p>Currently there are no valid bits and no protections against bursts crossing page boundaries</p>
<p>There needs to be a way to synchronize Request actions and DMA reads,
and to synchronize DMA writes with Indications, so that the writes
complete to the coherence point before the indication is delivered to
software. One could imagine an absurdly buffered memory interface and
a rather direct path for I/O reads that could get out of order.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">What is Connectal?</a><ul>
<li><a class="reference internal" href="#lexicon">Lexicon</a></li>
<li><a class="reference internal" href="#example-setups">Example setups:</a></li>
<li><a class="reference internal" href="#background">Background</a></li>
<li><a class="reference internal" href="#overview">Overview</a></li>
<li><a class="reference internal" href="#an-example">An Example</a></li>
<li><a class="reference internal" href="#simple-top-bsv">simple/Top.bsv</a></li>
<li><a class="reference internal" href="#simple-testsimple-cpp">simple/testsimple.cpp</a></li>
<li><a class="reference internal" href="#simple-example-design-structure">Simple Example Design Structure</a><ul>
<li><a class="reference internal" href="#make-verilog">make verilog</a></li>
<li><a class="reference internal" href="#make-bits">make bits</a></li>
<li><a class="reference internal" href="#make-android-exe">make android_exe</a></li>
<li><a class="reference internal" href="#make-run">make run</a></li>
</ul>
</li>
<li><a class="reference internal" href="#shared-memory">Shared Memory</a><ul>
<li><a class="reference internal" href="#shared-memory-hardware">Shared Memory Hardware</a></li>
<li><a class="reference internal" href="#shared-memory-software">Shared Memory Software</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notes">Notes</a><ul>
<li><a class="reference internal" href="#stewart-notes">stewart notes</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="portalstructure.html"
                        title="previous chapter">Portal Interface Structure</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="interface_definitions.html"
                        title="next chapter">Interface Declarations</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/design/portal.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../bsv-pkgindex.html" title="Bsv Package Index"
             >bsvpkgs</a> |</li>
        <li class="right" >
          <a href="interface_definitions.html" title="Interface Declarations"
             >next</a> |</li>
        <li class="right" >
          <a href="portalstructure.html" title="Portal Interface Structure"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">connectal 20.05.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="design.html" >Connectal Design</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015-2020, Jamey Hicks, Myron King, John Ankcorn.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>