<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Implementing String Search &mdash; connectal 14.12.6 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '14.12.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="connectal 14.12.6 documentation" href="../index.html" />
    <link rel="up" title="Connectal Design" href="design.html" />
    <link rel="next" title="Workflow using Connectal" href="toolchain.html" />
    <link rel="prev" title="The Connectal Framework" href="connectal-framework.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../bsv-pkgindex.html" title="Bsv Package Index"
             >bsvpkgs</a> |</li>
        <li class="right" >
          <a href="toolchain.html" title="Workflow using Connectal"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="connectal-framework.html" title="The Connectal Framework"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">connectal 14.12.6 documentation</a> &raquo;</li>
          <li><a href="design.html" accesskey="U">Connectal Design</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="implementing-string-search">
<h1>Implementing String Search<a class="headerlink" href="#implementing-string-search" title="Permalink to this headline">¶</a></h1>
<p>Having covered the features of the Connectal at a high level, we now
explain more specifically how the framework can be applied to
implement the refinements outlined in Section <a class="reference internal" href="string-search.html#sec-strstr"><em>Accelerating String Search</em></a>.</p>
<div class="section" id="initial-implementation">
<h2>Initial Implementation<a class="headerlink" href="#initial-implementation" title="Permalink to this headline">¶</a></h2>
<p>The FPGA is connected to the host system with a PCIe bus, and to the
memory array with wires.  In addition to implementing a search kernel,
the hardware accelerator must communicate with the software components
and with the flash chips.  Communication with the software takes place
through portals, whose interface declaration is given below:</p>
<div class="highlight-python"><div class="highlight"><pre>interface StrstrRequest;
  method Action setupNeedle(Bit#(8) needleChars);
  method Action search(Bit#(32) haystackPtr,
                       Bit#(32) haystackLen);
endinterface
interface StrstrIndication;
  method Action searchResult(Int#(32) v);
  method Action setupComplete();
endinterface
</pre></div>
</div>
<p>The hardware implements the StrstrRequest interface, which the
software invokes (remotely) to specify the search string and the
location in flash memory to search.  The software implements the
StrstrIndication interface, which the hardware invokes (remotely) to
notify the software of configuration completion or search results.
The interface compiler generates a separate portal for each of these
interfaces. Within each portal, a dedicated unidirectional FIFO is
assigned to each logical interface method.</p>
<p>In our initial implementation the accelerator does not access system
memory directly, so the search string is transmitted to the
accelerator one character at a time via the {tt setupNeedle}
method. We will see in Section :ref:Sec-StringSearchSystemMemory` how
to use a pointer to system memory instead.</p>
<div class="section" id="invoking-hardware-from-software">
<h3>Invoking Hardware from Software<a class="headerlink" href="#invoking-hardware-from-software" title="Permalink to this headline">¶</a></h3>
<p>Because the StrStrRequest functionality is implemented in hardware,
the Connectal interface compiler generates a C++ textbf{proxy} with
the following interface to be invoked by the application software:</p>
<div class="highlight-python"><div class="highlight"><pre>class StrStrRequestProxy : public Portal {
public:
  void setupNeedle(uint32_t needleChars);
  void search(uint32_t haystackPtr,
              uint32_t haystackLen);
};
</pre></div>
</div>
<p>The implementation of StrStrRequestProxy marshals the arguments of
each method and en-queues them directly into their dedicated hardware
FIFOs. To execute searches in the FPGA fabric over data stored in
flash memory, the software developer simply instantiates
<em>StrStrRequestProxy</em> and invokes its methods:</p>
<div class="highlight-python"><div class="highlight"><pre>StrStrRequestProxy *proxy =
            new StrStrRequestProxy(...);
proxy-&gt;search(haystackPtr, haystackLen);
</pre></div>
</div>
<p>On the FPGA, the user implements the application logic as a BSV module
with the StrStrRequest interface. A <em>wrapper</em> is generated by
the interface compiler to connect this module to the hardware
FIFOs. The wrapper unmarshals messages that it receives and then
invokes the appropriate method in the StrStrRequest interface.  Here
is the BSV code that instantiates the generated wrapper and connects
it to the user&#8217;s texttt{mkStrStr} module:</p>
<div class="highlight-python"><div class="highlight"><pre>StrStrRequest strStr &lt;- mkStrStr(...);
StrStrRequestWrapper wrapper &lt;-
    mkStrStrRequestWrapper(strStr);
</pre></div>
</div>
<p>Figure <a href="#id1"><span class="problematic" id="id2">:ref:`Fig-msc1`_</span></a> shows how all the pieces of an application
implemented using Connectal work together when hardware functionality
is invoked remotely from software.  Direct access to the memory mapped
hardware FIFOs by the generated proxy running in user-mode is key to
the efficiency of our implementation strategy.</p>
<img alt="../_images/msc1.png.png" src="../_images/msc1.png.png" />
<div class="figure" id="fig-msc1">
<img alt="../_images/msc1.png" src="../_images/msc1.png" />
<p class="caption">SW invokes HW: <em>main</em> and <em>app HW</em> are implemented by the user.</p>
</div>
</div>
<div class="section" id="invoking-software-from-hardware">
<h3>Invoking Software from Hardware<a class="headerlink" href="#invoking-software-from-hardware" title="Permalink to this headline">¶</a></h3>
<p>Invoking software from hardware takes a slightly different form, due
primarily to the fact that <a href="#id3"><span class="problematic" id="id4">``</span></a>main&#8217;&#8217; is still owned by software.  Since
the direction of the remote invocation is reversed, the proxy on this
path will be instantiated on the FPGA and the wrapper instantiated on
host side.  The user implements the StrStrResponse interface in
software and connects it to the generated wrapper using C++
subclasses:</p>
<div class="highlight-python"><div class="highlight"><pre>class StrStrResponse:
  public StrStrResponseWrapper {
    ...
  void searchResult(int32_t v) {...}
}
</pre></div>
</div>
<p>The StrStrResponseWrapper constructor registers a pointer to the
object with the event library which keeps track of all instantiated
software wrappers.  The wrapper implementation unmarshals messages
sent through the hardware FIFOs and invokes the appropriate subclass
interface method.  To activate this path, main simply instantiates the
response implementation and invokes the library event handler:</p>
<div class="highlight-python"><div class="highlight"><pre>StrStrResponse *response =
  new StrStrResponse(...);
while(1)
  portalExec_event();
</pre></div>
</div>
<p>On the invocation side, the interface compiler generates a proxy which
the application logic instantiates and invokes directly:</p>
<div class="highlight-python"><div class="highlight"><pre>StrStrResponseProxy proxy &lt;-
     mkStrStrRequestProxy();
StrStrRequest strStr &lt;-
     mkStrStr(... proxy.ifc ...);
</pre></div>
</div>
<p>Figure :ref:Fig-msc0 shows how all the pieces of an application
collaborate when software functionality is being invoked from
hardware.</p>
<img alt="../_images/msc0.png.png" src="../_images/msc0.png.png" />
<div class="figure" id="fig-msc0">
<img alt="../_images/msc0.png" src="../_images/msc0.png" />
<p class="caption">HW invokes SW: <a href="#id5"><span class="problematic" id="id6">`</span></a>main&#8217;, <a href="#id7"><span class="problematic" id="id8">`</span></a>ind::wrapper&#8217;, and <a href="#id9"><span class="problematic" id="id10">`</span></a>app HW&#8217; are implemented by the user.</p>
<div class="legend">
</div>
</div>
<p>The simplest software execution environment for the string search accelerator
is to have a single thread making requests and waiting for responses as
follows:</p>
<div class="highlight-python"><div class="highlight"><pre>void search(char *str){
  StrStrRequestProxy *req =
    new StrStrRequestProxy(...);
  StrStrResponse *resp =
    new StrStrResponse(...);
  while (char c = *str++)
    req-&gt;setupNeedle(c);
  // start search
  req-&gt;search(...);
  // handle responses from the HW
  while(1)
    portalExec_event();
}
</pre></div>
</div>
<p>The call to :c:func:portalExec_event() checks for a response from HW.  If
there is a pending response, it invokes the method corresponding to
that FIFO in the wrapper class.  This generated method reads out a
complete message from the FIFO and unmarshals it before invoking the
user-defined call-back function, which in this case would be
texttt{StrStrResponse::searchResult}.</p>
</div>
<div class="section" id="connecting-to-flash">
<h3>Connecting To Flash<a class="headerlink" href="#connecting-to-flash" title="Permalink to this headline">¶</a></h3>
<p>On BlueDBM, one of our target platforms, the flash memory array is connected directly
to the FPGA chip, and DDR signals are used to read/write/erase flash
memory cells. The RTL required to communicate with the memory requires
some commonly used functionality, such as <em>SerDes</em> and DDR
controllers, both of which are included in the BSV libraries
distributed as part of the Connectal framework.</p>
</div>
</div>
<div class="section" id="multithreading-the-software">
<h2>Multithreading The Software<a class="headerlink" href="#multithreading-the-software" title="Permalink to this headline">¶</a></h2>
<p>In many cases, we would like to avoid a hardware-to-software path
which requires the software to poll a hardware register on the other
side of a bus for relatively infrequent events.  To accommodate this,
the Connectal framework generates interrupts which are raised when
hardware invokes software interface methods.  The generic Connectal
driver connects these signals to the Linux kernel and the software
wrappers can exploit then by calling poll.  Connectal applications
often use a separate thread to execute hardware-to-software
asynchronous invocations, since dedicated thread can put itself to sleep until the
hardware raises an interrupt.  The <a href="#id11"><span class="problematic" id="id12">``</span></a>main&#8217;&#8217; thread is free to do other
work and can communicate with the <a href="#id13"><span class="problematic" id="id14">``</span></a>indication&#8217;&#8217; thread using a
semaphore as shown below:</p>
<div class="highlight-python"><div class="highlight"><pre>class StrStrResponse:
    public StrStrResponseWrapper {
  sem_t sem;
  int v;
  void searchResult(int32_t v) {
    this-&gt;response = v;
    sem_post(&amp;sem);
  }
  void waitResponse(){sem_wait(&amp;sem);}
};
StrStrResponse *resp;
StrStrRequestProxy *req;
int search(char *str){
  while (char c = *str++)
    req-&gt;setupNeedle(c);
  // start search
  req-&gt;search(...);
  // wait for response
  resp-&gt;waitResponse();
  // return result
  return resp-&gt;v;
}
</pre></div>
</div>
<p>The polling thread is started by a call
to :c:func:portalExec_start(), which ultimately invokes
the :c:func:portalExec_poll() function implemented in the Connectal
event library.  :c:func:portalExec_poll() invokes the system call
textbf{poll} on the FDs corresponding to all the indication or response portals,
putting itself to sleep.  When an interface method is invoked in the
hardware proxy, an interrupt is raised, waking the indication thread.
A register is read which indicates which method is being called and
the corresponding wrapper method is invoked to read/marshal the
arguments and invoke the actual user-defined methods.
Figure <em class="xref std std-ref">Fig-msc2</em> shows this process.</p>
<img alt="../_images/msc2.png" src="../_images/msc2.png" />
<p>Multithreading often leads to simultaneous access to shared
hardware resources.  If a software solution to protect
these resources (such as mutex) is not available, the hardware interface
can be refactored into separate portals, one for each control thread.</p>
<p>Each interface will generate a separate Portal which is assigned its own
address space and Linux device.  Using Linux devices in this way
enables access control restrictions to be specified individually for
each portal.  This feature can be used to grant different users or
processes exclusive access and prevent unauthorized access to specific
pieces of hardware functionality.</p>
</div>
<div class="section" id="shared-access-to-host-memory">
<h2>Shared Access to Host Memory<a class="headerlink" href="#shared-access-to-host-memory" title="Permalink to this headline">¶</a></h2>
<p>In the first three refinements presented in Section <a class="reference internal" href="string-search.html#sec-strstr"><em>Accelerating String Search</em></a>,
all communication between hardware and software takes place through
register-mapped IO.  The final refinement in
Section <em class="xref std std-ref">Sec-StrStrDma</em> is to grant hardware and software shared
access to host memory.  The interface to the search accelerator shown
below has been updated to use direct access to system memory for the
search strings:</p>
<div class="highlight-python"><div class="highlight"><pre>interface StrstrRequest;
  method Action setup(Bit#(32) needlePtr,
                      Bit#(32) mpNextPtr,
                      Bit#(32) needleLen);
  method Action search(Bit#(32) haystackPtr,
                       Bit#(32) haystackLen,
                       Bit#(32) iterCount);
endinterface
interface StrstrIndication;
   method Action searchResult(Int#(32) v);
   method Action setupComplete();
endinterface
</pre></div>
</div>
<p>In order to share memory with hardware accelerators, it needs to be
allocated using :c:func:portalAlloc(). Here is the search function updated
accordingly:</p>
<div class="highlight-python"><div class="highlight"><pre>int search(char *str){
  int size = strlen(str)+1;
  int fd = portalAlloc(size);
  char *sharedStr = portalMmap(fd, size);
  strcpy(sharedStr, str);
  // send a DMA reference to the search pattern
  req-&gt;needle(dma-&gt;reference(fd), size);
  // start search
  req-&gt;search(...);
  resp-&gt;waitResponse();
  ... unmap and free the string
  return resp-&gt;v;
}
</pre></div>
</div>
<p>The application allocates shared memory via {tt portalAlloc}, which
returns a file descriptor, and then passes that file descriptor to
{tt mmap}, which maps the physical pages into the application&#8217;s
address space. The file descriptor corresponds to a
dmabufcite{dmabuf}, which is a standard Linux kernel mechanism.</p>
<dl class="docutils">
<dt>To share that memory with the accelerator, the application calls {tt</dt>
<dd>reference}, which sends a logical to physical address</dd>
<dt>mapping to the hardware&#8217;s address translator. The call to {tt</dt>
<dd>reference} returns a handle, which the application sends to</dd>
</dl>
<p>the accelerator. Connectal&#8217;s BSV libraries for DMA enable the
accelerator to read or write from offsets to these handles,
taking care of address translation transparently.</p>
<p>To fully exploit the data parallelism, {tt mkStrStr} partitions the
search space into $p$ partitions. It instantiates two memory read
trees from the Connectal library ({tt MemreadEngineV}, discussed in
Section <a class="reference internal" href="connectal-framework.html#sec-memreadengine"><em>Distributed Access to Memory Ports</em></a>, each with $p$ read servers.  One set
is used by the search kernels to read the configuration data from the
host memory, while the other is used to read the <a href="#id15"><span class="problematic" id="id16">``</span></a>haystack&#8217;&#8217; from
flash.</p>
<p>On supported platforms such as Zynq which provide multiple physical
master connections to system memory, Connectal interleaves DMA
requests over the parallel links. It does this on a per-read-client
basis, rather than a per-request basis.</p>
</div>
<div class="section" id="alternate-portal-implementations">
<h2>Alternate Portal Implementations<a class="headerlink" href="#alternate-portal-implementations" title="Permalink to this headline">¶</a></h2>
<p>Connectal separates the generation of code for marshalling and
unmarshaling method arguments from the transport mechanism used to
transmit the messages. This separation enables <a href="#id17"><span class="problematic" id="id18">``</span></a>swappable&#8217;&#8217;
application-specific transport libraries.  In light of this, a large
number of transport mechanism can be considered. Switching between
mechanism requires a simple directive in the project Makefile (more
details are given in Section <em class="xref std std-ref">Sec-ToolChain</em>).</p>
<p>By default, each portal is mapped to a region of address space and a
memory-mapped FIFO channel is generated for each method. Though
software access to all FIFO channels in a design may occur through
single bus slave interface, Connectal libraries implement their
multiplexing to ensure that each FIFO is independent, allowing
concurrent access to different methods from multiple threads or
processes.</p>
<p>The default portal library implements the method FIFOs in the hardware
accelerator. This provides the lowest latency path between hardware
and software, taking about 1 microsecond to send a message. If higher
bandwidth or transaction rates are needed, FIFOs implemented as a ring buffer in DRAM can be
used instead.  This requires more instructions per message send and
receive, but may achieve higher throughput between the CPU and
hardware.</p>
<p>During the design exploration process, a component originally
implemented on the FPGA may migrate to software running on the host
processor.  Remote invocations which were originally from software to
hardware must be recast as software to software. Without changing the
IDL specification, the transport mechanism assigned to a portal can be
re-specified to implement communication between software components
running either on the same host or across a network.</p>
<p>Connectal uses UNIX sockets or shared memory to transport messages
between the application software components or the hardware simulator.
In other situations, TCP or UDP can be used to transport the messages
to hardware running on another machine.  Viable connections to the
FPGA board range from low-speed interconnects such as JTAG, SPI, to
higher-speed interconnects such as USB or Aurora over multi-gigabit
per second transceivers.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Implementing String Search</a><ul>
<li><a class="reference internal" href="#initial-implementation">Initial Implementation</a><ul>
<li><a class="reference internal" href="#invoking-hardware-from-software">Invoking Hardware from Software</a></li>
<li><a class="reference internal" href="#invoking-software-from-hardware">Invoking Software from Hardware</a></li>
<li><a class="reference internal" href="#connecting-to-flash">Connecting To Flash</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multithreading-the-software">Multithreading The Software</a></li>
<li><a class="reference internal" href="#shared-access-to-host-memory">Shared Access to Host Memory</a></li>
<li><a class="reference internal" href="#alternate-portal-implementations">Alternate Portal Implementations</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="connectal-framework.html"
                        title="previous chapter">The Connectal Framework</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="toolchain.html"
                        title="next chapter">Workflow using Connectal</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/design/implementing-string-search.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../bsv-pkgindex.html" title="Bsv Package Index"
             >bsvpkgs</a> |</li>
        <li class="right" >
          <a href="toolchain.html" title="Workflow using Connectal"
             >next</a> |</li>
        <li class="right" >
          <a href="connectal-framework.html" title="The Connectal Framework"
             >previous</a> |</li>
        <li><a href="../index.html">connectal 14.12.6 documentation</a> &raquo;</li>
          <li><a href="design.html" >Connectal Design</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Jamey Hicks, Myron King, John Ankcorn.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>